#!/bin/bash

set -euo pipefail

###

RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

function _info() {
    echo -e "${BLUE}INFO: $1${NC}"
}

function _error() {
    echo -e "${RED}ERROR: $1${NC}" >&2
}

function _fatal() {
    _error "$1"; exit 1;
}

####

function find_between_markers() {
    local text="$1"
    local begin_marker="$2"
    local end_marker="$3"

    [[ -z "$begin_marker" ]] && \
        _fatal "find_between_markers: Missing begin marker."
    [[ -z "$end_marker" ]] && \
        _fatal "find_between_markers: Missing end marker."

    local result=""
    trap 'echo "${result:-}"' RETURN

    # no text or markers, return empty string
    [[ -z "$text" ]] && exit 0
    [[ "$text" == *"$begin_marker"* ]] || exit 0
    [[ "$text" == *"$end_marker"* ]] || exit 0

    result="${text#*"$begin_marker"}"
    result="${result%%"$end_marker"*}"
}

# Find all issue numbers in the text
# Returns a sorted list of unique issue numbers without the '#' prefix
# Example: "Fixes #123, #456" will return "123 456"
# If no issue numbers are found, returns an empty string
function find_issue_numbers() {
    local text="$1"

    local result=""
    trap 'echo "${result:-}"' RETURN

    [[ -z "$text" ]] && exit 0

    # TODO: this is a bit messy, but works for now
    result=$(
        echo "$text" |
        # match only one '#' followed by digits and grab one more character
        grep -o '[^#]#[0-9]\+.' |
        # allow the last character to be a common punctuation marker, a space or a number
        # then blow up the first character, the last character (unless its a digit) and the '#'
        sed -n '/.*[0-9 ,.;()]$/ { s/^.//; s/[^0-9]$//; s/#//; p }' |
        # sort and unique
        sort -u |
        # swap from newlines to spaces and remove trailing
        tr '\n' ' ' | sed 's/ $//'
    )
}

####

START_MARKER="<!-- ðŸ¤– FORWARD PORTING BEGIN -->"
END_MARKER="<!-- ðŸ¤– FORWARD PORTING END -->"

function main() {
    local body="$1"
    [[ -n "$body" ]] || \
        _fatal "No body provided."

    local forward_porting=$(find_between_markers "$body" "$START_MARKER" "$END_MARKER")
    [[ -n "$forward_porting" ]] || \
        _fatal "No forward porting section found in the body."

    _info "Forward porting section found:"
    echo "$forward_porting"
}

# Check if the script is being run directly or sourced
# If sourced, do not execute main
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi