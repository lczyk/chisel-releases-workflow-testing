#!/bin/bash

set -euo pipefail

###

RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

function _info() {
    echo -e "${BLUE}INFO: $1${NC}"
}

function _error() {
    echo -e "${RED}ERROR: $1${NC}" >&2
}

function _fatal() {
    _error "$1"; exit 1;
}

####

# Find text between two markers
# Returns the text between the markers, or an empty string if not found
function find_between_markers() {
    local text="$1"
    local begin_marker="$2"
    local end_marker="$3"

    [[ -z "$begin_marker" ]] && \
        _fatal "find_between_markers: Missing begin marker."
    [[ -z "$end_marker" ]] && \
        _fatal "find_between_markers: Missing end marker."

    local result=""
    trap 'echo "${result:-}"' RETURN

    # no text or markers, return empty string
    [[ -z "$text" ]] && exit 0
    [[ "$text" == *"$begin_marker"* ]] || exit 0
    [[ "$text" == *"$end_marker"* ]] || exit 0

    result="${text#*"$begin_marker"}"
    result="${result%%"$end_marker"*}"
}

# Find all issue numbers in the text
# Returns a sorted list of unique issue numbers without the '#' prefix
# Example: "Fixes #123, #456" will return "123 456"
# If no issue numbers are found, returns an empty string
function find_issue_numbers() {
    local text="$1"

    local result=""
    trap 'echo "${result:-}"' RETURN

    [[ -z "$text" ]] && exit 0

    # Extract issue numbers in the format #123, #456, etc.
    result=$(
        echo "$text" |
        # match only one '#' followed by digits and grab one more character
        grep -o '[^#]#[0-9]\+.' |
        # allow the last character to be a common punctuation marker, a space or a number
        # then blow up the first character, the last character (unless its a digit) and the '#'
        sed -n '/.*[0-9 ,.;()]$/ { s/^.//; s/[^0-9]$//; s/#//; p }'
    )

    # Extract issue numbers which are markdown links
    # e.g. [here](http://github.com/canonical/chisel-releases/pull/123)
    # We accept http, https and no protocol links
    local pr_base='github.com/canonical/chisel-releases/pull'
    result+=$(
        echo "$text" |
        # NOTE: we do need the `-P` option for Perl regex support
        # due to the non-greedy match `.*?` and non-capturing group `(?:...)`
        grep -oP '\[.*?\]\((?:https?://)?'"$pr_base"'/[0-9]+\)' |
        # extract the issue number from the link
        sed "s/.*${pr_base//\//\\/}\///;s/)$//;"
    )

    # Final processing
    result=$(
        echo "$result" |
        # sort and unique
        sort -u |
        # swap from newlines to spaces and remove trailing
        tr '\n' ' ' | sed 's/ $//'
    )
}

####

START_MARKER="<!-- ðŸ¤– FORWARD PORTING BEGIN -->"
END_MARKER="<!-- ðŸ¤– FORWARD PORTING END -->"

# All the current ubuntu versions
UBUNTU_VERSIONS=(
    "20.04" # Focal (LTS)
    "22.04" # Jammy (LTS)
    "24.04" # Noble (LTS)
    "25.04" # Plucky
)

function main() {
    local body="$1"
    [[ -n "$body" ]] || \
        _fatal "No body provided. Expected the body of the PR message."

    local base_ref="$2"
    [[ -n "$base_ref" ]] || \
        _fatal "No base ref provided. Expected something like 'ubuntu-24.04'"

    # Find out which ubuntu version is this PR for
    local ubuntu_version=$(echo "$base_ref" | sed -n 's/^ubuntu-\([0-9]\+\.[0-9]\+\)/\1/p')
    [[ -n "$ubuntu_version" ]] || \
        _fatal "Could not determine the Ubuntu version from the base ref '$base_ref'."

    # Check if the ubuntu version is supported
    local is_supported=false
    for version in "${UBUNTU_VERSIONS[@]}"; do
        if [[ "$version" == "$ubuntu_version" ]]; then
            is_supported=true
            break
        fi
    done
    [[ "$is_supported" == true ]] || \
        _fatal "The Ubuntu version '$ubuntu_version' is not supported by this script. Supported versions are: ${UBUNTU_VERSIONS[*]}."

    _info "Ubuntu version '$ubuntu_version' is supported."

    # Find the issue numbers in the body of the PR
    local forward_porting=$(find_between_markers "$body" "$START_MARKER" "$END_MARKER")
    [[ -n "$forward_porting" ]] || \
        _fatal "No forward porting section found in the body."

    _info "Forward porting section found:"
    echo "$forward_porting"

    local issue_numbers=$(find_issue_numbers "$forward_porting")
    if [[ -n "$issue_numbers" ]]; then
        _fatal "Issue numbers not implemented"        
    else
        _fatal "No issue numbers not implemented"
    fi

}

# Check if the script is being run directly or sourced
# If sourced, do not execute main
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi