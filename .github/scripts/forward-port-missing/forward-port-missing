#!/bin/bash

set -euo pipefail

## LOGGING #####################################################################

RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

function _info() {
    echo -e "${BLUE}INFO: $1${NC}"
}

function _error() {
    echo -e "${RED}ERROR: $1${NC}" >&2
}

function _fatal() {
    _error "$1"; exit 1;
}

## FIND BETWEEN MARKERS ########################################################

# Find text between two markers
# Returns the text between the markers, or an empty string if not found
function find_between_markers() {
    local text="$1"
    local begin_marker="$2"
    local end_marker="$3"

    [[ -z "$begin_marker" ]] && \
        _fatal "find_between_markers: Missing begin marker."
    [[ -z "$end_marker" ]] && \
        _fatal "find_between_markers: Missing end marker."

    local result=""
    trap 'echo "${result:-}"' RETURN

    # no text or markers, return empty string
    [[ -z "$text" ]] && exit 0
    [[ "$text" == *"$begin_marker"* ]] || exit 0
    [[ "$text" == *"$end_marker"* ]] || exit 0

    result="${text#*"$begin_marker"}"
    result="${result%%"$end_marker"*}"
}

# Find all issue numbers in the text
# Returns a sorted list of unique issue numbers without the '#' prefix
# Example: "Fixes #123, #456" will return "123 456"
# If no issue numbers are found, returns an empty string

# _DEFAULT_PR_BASE='github.com/canonical/chisel-releases/pull'
_DEFAULT_PR_BASE='github.com/lczyk/chisel-releases-workflow-testing/pull'

function find_issue_numbers() {
    local text="$1"
    local pr_base="${2:-$_DEFAULT_PR_BASE}"

    local result=""
    trap 'echo "${result:-}"' RETURN

    [[ -z "$text" ]] && exit 0

    # Extract issue numbers in the format #123, #456, etc.
    result=$(
        echo "$text" |
        # match only one '#' followed by digits and grab one more character
        grep -o '[^#]#[0-9]\+.' |
        # allow the last character to be a common punctuation marker, a space or a number
        # then blow up the first character, the last character (unless its a digit) and the '#'
        sed -n '/.*[0-9 ,.;()]$/ { s/^.//; s/[^0-9]$//; s/#//; p }'
    )

    # Extract issue numbers which are markdown links
    # e.g. [here](http://github.com/canonical/chisel-releases/pull/123)
    # We accept http, https and no protocol links
    result+=$(
        echo "$text" |
        # NOTE: we do need the `-P` option for Perl regex support
        # due to the non-greedy match `.*?` and non-capturing group `(?:...)`
        grep -oP '\[.*?\]\((?:https?://)?'"$pr_base"'/[0-9]+\)' |
        # extract the issue number from the link
        sed "s/.*${pr_base//\//\\/}\///;s/)$//;"
    )

    # Final processing
    result=$(
        echo "$result" |
        # sort and unique
        sort -u |
        # swap from newlines to spaces and remove trailing
        tr '\n' ' ' | sed 's/ $//'
    )
}

## FIND GREATER VERSIONS #######################################################

# Given a current version and a list of other versions,
# find out which forward ports are needed.
# For example, if called with "1.9.0" and "1.7.0 1.8.0 1.9.1 1.10.0",
# it should return "1.9.1 1.10.0"
# The versions need not be sorted
function find_greater_versions() {
    local this_version="$1"
    local other_versions="${@:2}"

    [[ -z "$other_versions" ]] && \
        _fatal "find_greater_versions: No other versions provided."

    function drop_non_version() {
        sed 's/[^0-9.]*//g'
    }

    local this_version_cmp=$(echo "$this_version" | drop_non_version)
    [[ -z "$this_version_cmp" ]] && \
        _fatal "find_greater_versions: Invalid this version '$this_version'."

    local result=()

    for version in $other_versions; do
        local version_cmp=$(echo "$version" | drop_non_version)
        [[ -z "$version_cmp" ]] && continue
        # # Check if the version is greater than the current version
        if [[ "$version_cmp" > "$this_version_cmp" ]]; then
            # Add the version to the result
            result+=("$version")
        fi
    done

    # Final processing
    printf "%s\n" "${result[@]}" |
        # sort and unique
        sort -u |
        # swap from newlines to spaces and remove trailing space
        tr '\n' ' ' | sed 's/ $//'
}

## MAIN ########################################################################

START_MARKER="<!-- ðŸ¤– FORWARD PORTING BEGIN -->"
END_MARKER="<!-- ðŸ¤– FORWARD PORTING END -->"

# All the current ubuntu versions
UBUNTU_VERSIONS=(
    "20.04" # Focal (LTS)
    "22.04" # Jammy (LTS)
    "24.04" # Noble (LTS)
    "25.04" # Plucky
)

function main() {
    local body="$1"
    [[ -n "$body" ]] || \
        _fatal "No body provided. Expected the body of the PR message."

    local base_ref="$2"
    [[ -n "$base_ref" ]] || \
        _fatal "No base ref provided. Expected something like 'ubuntu-24.04'"

    # Find out which ubuntu version is this PR for
    local ubuntu_version=$(echo "$base_ref" | sed -n 's/^ubuntu-\([0-9]\+\.[0-9]\+\)/\1/p')
    [[ -n "$ubuntu_version" ]] || \
        _fatal "Could not determine the Ubuntu version from the base ref '$base_ref'."

    # Check if the ubuntu version is supported
    local is_supported=false
    for version in "${UBUNTU_VERSIONS[@]}"; do
        if [[ "$version" == "$ubuntu_version" ]]; then
            is_supported=true
            break
        fi
    done
    [[ "$is_supported" == true ]] || \
        _fatal "The Ubuntu version '$ubuntu_version' is not supported by this script. Supported versions are: ${UBUNTU_VERSIONS[*]}."

    # _info "This is a PR into Ubuntu version '$ubuntu_version'"

    # Find the issue numbers in the body of the PR
    local forward_porting=$(find_between_markers "$body" "$START_MARKER" "$END_MARKER")
    [[ -n "$forward_porting" ]] || \
        _fatal "No forward porting section found in the body."

    # _info "Forward porting section found:"
    # echo "$forward_porting"

    local issue_numbers=$(find_issue_numbers "$forward_porting")
    if [[ -n "$issue_numbers" ]]; then
        if [[ "$ubuntu_version" == "${UBUNTU_VERSIONS[-1]}" ]]; then
            _info "This is a PR into the latest Ubuntu version '${UBUNTU_VERSIONS[-1]}'."
            _info "Found issue numbers in the forward porting section: $issue_numbers"
            _info "No action needed, as this is the latest version."
            exit 0
        else
            _info "This is a PR into an older Ubuntu version '$ubuntu_version'."
            _info "Found issue numbers in the forward porting section: $issue_numbers"
            
            linked_versions=$(_find_versions_in_linked_issues "$issue_numbers")
            echo "Linked versions found: $linked_versions"

            local greater_versions=$(find_greater_versions "$ubuntu_version" "${UBUNTU_VERSIONS[@]}")
            [[ -n "$greater_versions" ]] || \
                _fatal "No greater versions found for the Ubuntu version '$ubuntu_version'."
            _info "The following greater versions are available: $greater_versions"
           # TODO: We know what forward ports are needed, and we know which branches do
           #       we point to as forward ports. We just need to check if there are any
           #       forward ports missing.
            exit 0
        fi
    else
        # Is this a pr into the latest Ubuntu version?
        if [[ "$ubuntu_version" == "${UBUNTU_VERSIONS[-1]}" ]]; then
            _info "This is a PR into the latest Ubuntu version '${UBUNTU_VERSIONS[-1]}'."
            _info "No issue numbers found in the forward porting section, but none are needed"
            exit 0
        else
            _info "This is a PR into an older Ubuntu version '$ubuntu_version'."
            _info "No issue numbers found in the forward porting section, so will mark this PR as missing forward porting."
            _mark_this_PR_as_forward_port_missing || exit 1
        fi
    fi
}

function _mark_this_PR_as_forward_port_missing() {
    # Check if we're running in a GitHub Actions environment
    if [[ -n "${GITHUB_ACTIONS:-}" ]]; then
        # Extract PR number from GITHUB_REF_NAME: everything before first slash
        local pr_number=${GITHUB_REF_NAME%%/*}
        [[ -n "$pr_number" ]] || \
            _fatal "Could not determine the PR number from GITHUB_REF_NAME '$GITHUB_REF_NAME'."
        _info "Marking PR #$pr_number as missing forward porting."
        gh pr edit "$pr_number" --add-label "forward port missing" || \
            _fatal "Failed to mark PR #$pr_number as missing forward porting. Please check the GitHub CLI configuration."
    else
        # If not in GitHub Actions, just print a message
        _info "This PR is missing forward porting. Please check the forward porting section."
    fi
    return 0
}

function _find_versions_in_linked_issues() {
    local issue_numbers="$1"
    [[ -n "$issue_numbers" ]] || \
        _fatal "_find_versions_in_linked_issues: No issue numbers provided."

    local result=()
    for issue in $issue_numbers; do
        echo "Processing issue #$issue"
        # We get a bunch of issue numbers., They may or, indeed, may not exist on
        # 
        # We need to get the base_ref for each issue number
        # 
        result+=("v1.0.0")  # Simulated version
    done

    printf "%s\n" "${result[@]}" |
        sort -u |
        tr '\n' ' ' | sed 's/ $//'
}

## ENTRY POINT #################################################################

# Check if the script is being run directly or sourced
# If sourced, do not execute main (we source this script in tests)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi