#!/bin/bash

set -euo pipefail

###

RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

function _info() {
    echo -e "${BLUE}INFO: $1${NC}"
}

function _error() {
    echo -e "${RED}ERROR: $1${NC}" >&2
}

function _fatal() {
    _error "$1"; exit 1;
}

################################################################################

# Find text between two markers
# Returns the text between the markers, or an empty string if not found
function find_between_markers() {
    local text="$1"
    local begin_marker="$2"
    local end_marker="$3"

    [[ -z "$begin_marker" ]] && \
        _fatal "find_between_markers: Missing begin marker."
    [[ -z "$end_marker" ]] && \
        _fatal "find_between_markers: Missing end marker."

    local result=""
    trap 'echo "${result:-}"' RETURN

    # no text or markers, return empty string
    [[ -z "$text" ]] && exit 0
    [[ "$text" == *"$begin_marker"* ]] || exit 0
    [[ "$text" == *"$end_marker"* ]] || exit 0

    result="${text#*"$begin_marker"}"
    result="${result%%"$end_marker"*}"
}

# Find all issue numbers in the text
# Returns a sorted list of unique issue numbers without the '#' prefix
# Example: "Fixes #123, #456" will return "123 456"
# If no issue numbers are found, returns an empty string
function find_issue_numbers() {
    local text="$1"

    local result=""
    trap 'echo "${result:-}"' RETURN

    [[ -z "$text" ]] && exit 0

    # Extract issue numbers in the format #123, #456, etc.
    result=$(
        echo "$text" |
        # match only one '#' followed by digits and grab one more character
        grep -o '[^#]#[0-9]\+.' |
        # allow the last character to be a common punctuation marker, a space or a number
        # then blow up the first character, the last character (unless its a digit) and the '#'
        sed -n '/.*[0-9 ,.;()]$/ { s/^.//; s/[^0-9]$//; s/#//; p }'
    )

    # Extract issue numbers which are markdown links
    # e.g. [here](http://github.com/canonical/chisel-releases/pull/123)
    # We accept http, https and no protocol links
    local pr_base='github.com/canonical/chisel-releases/pull'
    result+=$(
        echo "$text" |
        # NOTE: we do need the `-P` option for Perl regex support
        # due to the non-greedy match `.*?` and non-capturing group `(?:...)`
        grep -oP '\[.*?\]\((?:https?://)?'"$pr_base"'/[0-9]+\)' |
        # extract the issue number from the link
        sed "s/.*${pr_base//\//\\/}\///;s/)$//;"
    )

    # Final processing
    result=$(
        echo "$result" |
        # sort and unique
        sort -u |
        # swap from newlines to spaces and remove trailing
        tr '\n' ' ' | sed 's/ $//'
    )
}

################################################################################

# Given a current version and a list of other versions,
# find out which forward ports are needed.
# For example, if called with "1.9.0" and "1.7.0 1.8.0 1.9.1 1.10.0",
# it should return "1.9.1 1.10.0"
# The versions need not be sorted
function find_greater_versions() {
    local this_version="$1"
    local other_versions="${@:2}"

    [[ -z "$other_versions" ]] && \
        _fatal "find_greater_versions: No other versions provided."

    function drop_non_version() {
        sed 's/[^0-9.]*//g'
    }

    local this_version_cmp=$(echo "$this_version" | drop_non_version)
    [[ -z "$this_version_cmp" ]] && \
        _fatal "find_greater_versions: Invalid this version '$this_version'."

    local result=()

    for version in $other_versions; do
        local version_cmp=$(echo "$version" | drop_non_version)
        [[ -z "$version_cmp" ]] && continue
        # # Check if the version is greater than the current version
        if [[ "$version_cmp" > "$this_version_cmp" ]]; then
            # Add the version to the result
            result+=("$version")
        fi
    done

    # Final processing
    printf "%s\n" "${result[@]}" |
        # sort and unique
        sort -u |
        # swap from newlines to spaces and remove trailing space
        tr '\n' ' ' | sed 's/ $//'
}

################################################################################

START_MARKER="<!-- ðŸ¤– FORWARD PORTING BEGIN -->"
END_MARKER="<!-- ðŸ¤– FORWARD PORTING END -->"

# All the current ubuntu versions
UBUNTU_VERSIONS=(
    "20.04" # Focal (LTS)
    "22.04" # Jammy (LTS)
    "24.04" # Noble (LTS)
    "25.04" # Plucky
)

function main() {
    local body="$1"
    [[ -n "$body" ]] || \
        _fatal "No body provided. Expected the body of the PR message."

    local base_ref="$2"
    [[ -n "$base_ref" ]] || \
        _fatal "No base ref provided. Expected something like 'ubuntu-24.04'"

    # Find out which ubuntu version is this PR for
    local ubuntu_version=$(echo "$base_ref" | sed -n 's/^ubuntu-\([0-9]\+\.[0-9]\+\)/\1/p')
    [[ -n "$ubuntu_version" ]] || \
        _fatal "Could not determine the Ubuntu version from the base ref '$base_ref'."

    # Check if the ubuntu version is supported
    local is_supported=false
    for version in "${UBUNTU_VERSIONS[@]}"; do
        if [[ "$version" == "$ubuntu_version" ]]; then
            is_supported=true
            break
        fi
    done
    [[ "$is_supported" == true ]] || \
        _fatal "The Ubuntu version '$ubuntu_version' is not supported by this script. Supported versions are: ${UBUNTU_VERSIONS[*]}."

    # _info "This is a PR into Ubuntu version '$ubuntu_version'"

    # Find the issue numbers in the body of the PR
    local forward_porting=$(find_between_markers "$body" "$START_MARKER" "$END_MARKER")
    [[ -n "$forward_porting" ]] || \
        _fatal "No forward porting section found in the body."

    # _info "Forward porting section found:"
    # echo "$forward_porting"

    local issue_numbers=$(find_issue_numbers "$forward_porting")
    if [[ -n "$issue_numbers" ]]; then
        if [[ "$ubuntu_version" == "${UBUNTU_VERSIONS[-1]}" ]]; then
            _info "This is a PR into the latest Ubuntu version '${UBUNTU_VERSIONS[-1]}'."
            _info "Found issue numbers in the forward porting section: $issue_numbers"
            _info "No action needed, as this is the latest version."
            exit 0
        else
            _info "This is a PR into an older Ubuntu version '$ubuntu_version'."
            _info "Found issue numbers in the forward porting section: $issue_numbers"
            # TODO: Crawl the issues to find out what, if any, ubuntu branches they point to
            #       and then compare with the forward ports which are needed.

            local greater_versions=$(find_greater_versions "$ubuntu_version" "${UBUNTU_VERSIONS[@]}")
            [[ -n "$greater_versions" ]] || \
                _fatal "No greater versions found for the Ubuntu version '$ubuntu_version'."
            _info "The following greater versions are available: $greater_versions"
           # TODO: We know what forward ports are needed, and we know which branches do
           #       we point to as forward ports. We just need to check if there are any
           #       forward ports missing.
            exit 0
        fi
    else
        # Is this a pr into the latest Ubuntu version?
        if [[ "$ubuntu_version" == "${UBUNTU_VERSIONS[-1]}" ]]; then
            _info "This is a PR into the latest Ubuntu version '${UBUNTU_VERSIONS[-1]}'."
            _info "No issue numbers found in the forward porting section, but none are needed"
            exit 0
        else
            _info "This is a PR into an older Ubuntu version '$ubuntu_version'."
            _info "No issue numbers found in the forward porting section, so will mark this PR as missing forward porting."
            _mark_this_PR_as_forward_port_missing || exit 1
        fi
    fi
}

function _mark_this_PR_as_forward_port_missing() {
    # TODO: This function should mark the PR as missing forward porting
    # For now, we just print a message
    _fatal "Marking this PR as missing forward porting is not implemented yet."
}


# Check if the script is being run directly or sourced
# If sourced, do not execute main
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi